---
title: "Processed GPS EDA"
author: "Claire Punturieri"
date: "`r lubridate::today()`"
format: 
  html:
    toc: true
    toc_depth: 4
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

# Housekeeping

## Code Status

Complete to lab workflow standards as of 6/2024.

## Conclusions   

EDA is conducted here using subjects with credible lapse reporting and at least one month of data (generated using mak_study_dates.qmd).

## Set up

## Environment
```{r}
#| message: false
#| warning: false

options(conflicts.policy = "depends.ok")
devtools::source_url("https://github.com/jjcurtin/lab_support/blob/main/format_path.R?raw=true", 
                      sha1 = "a58e57da996d1b70bb9a5b58241325d6fd78890f")
```

### Paths
```{r}
path_shared <- format_path("studydata/risk/data_processed/shared")
path_gps <- format_path("studydata/risk/data_processed/gps")
path_maps <- format_path("studydata/risk/data_processed/gps/subject-maps")
#path_notes <- format_path("GitHub/analysis_risk/shared/notes")
```

## Packages and plot settings
```{r}
#| message: false
#| warning: false

library(tidyverse)
library(readxl)
library(geosphere)
library(lubridate)
library(XML)
library(kableExtra, exclude = c("group_rows"))
# for maps
## static maps
#library(ggmap)
#register_stadiamaps("d4bd71d7-556a-4627-9515-ef6e96823ce3")
## dynamic maps
#library(moveVis) this package might have deprecated, look into if making more animated maps
#library(raster, exclude = c("select"))
#library(move)

# load in helpful lab functions
devtools::source_url("https://github.com/jjcurtin/lab_support/blob/main/fun_plots.R?raw=true",
  sha1 = "def6ce26ed7b2493931fde811adff9287ee8d874"
)
devtools::source_url("https://github.com/jjcurtin/lab_support/blob/main/fun_eda.R?raw=true",
 sha1 = "c045eee2655a18dc85e715b78182f176327358a7"
)

# adjust plot visuals
theme_set(theme_classic())
options(tibble.width = Inf, dplyr.print_max = Inf)
```


## Examine individual participant data

### Load in data
```{r}
gps <- read_csv(here::here(path_shared, "gps.csv"), show_col_types = FALSE) |>
  relocate(subid)  |>
  mutate(date_central = date(time)) |> 
  glimpse()

# having trouble loading this in
# staff notes on subject gps quality
#notes <- read_csv(here::here(path_notes, "notes_raw.csv"), show_col_types = FALSE)

# dates of screening, intake, and follow-up visits
study_dates <- read_csv(here::here(path_gps, "study_dates.csv"), show_col_types = FALSE) |> 
  glimpse()
```

### Filter subjects with minimum amount of data

Pull list of subject IDs with at least one month data and credible lapse reporting.
```{r}
subids_dates <- study_dates |>  
  pull(subid) |>  
  unique()
```

Filter out subjects not included in study_dates.
```{r}
gps <-  gps |>  
  filter(subid %in% subids_dates)

gps |> pull(subid) |> unique() |> length()
```

### Count number of observations, including missing days

Count n_obs per day by subject -- this will only count days for which participants have at least one data point.
```{r}
gps_obs <- gps |>
  mutate(date_central = date(time)) |> 
  group_by(subid, date_central) |>  
  summarise(n_obs = n())
```

Create data frame listing out all dates each subject was on study and should have had data.
```{r}
dates_long <- study_dates |> 
  select(subid, study_start, study_end) |> 
  pivot_longer(cols = starts_with("study"), names_to = "point",
               values_to = "time") |> 
  mutate(date_central = date(time)) |> 
  group_by(subid) |>
  complete(date_central = full_seq(date_central, 1), fill = list(dummy = 0)) |> 
  select(-time)
```

Merge with gps_obs. This will create "blank" days for days when subjects were on study but no data points were collected, which we can then fill in with 0s.

> Here I think we want to left_join because we only care about data points that are in the study_dates start and end range (sometimes GPS data was collected pre- and post-study, but that's not relevant to us).

```{r}
gps_obs <- dates_long |> 
  select(-point) |> 
  left_join(gps_obs, by = c("subid", "date_central")) |> 
  mutate(n_obs = if_else(is.na(n_obs), 0, n_obs))
```

### Number of observations per person

```{r}
n_obs <- gps_obs |> 
  group_by(subid) |> 
  summarize(mean_nobs = mean(n_obs), median_nobs = median(n_obs), 
            n_days = n(), n_missing = sum(n_obs == 0), 
            per_missing = n_missing / n_days)
```



Display histogram of # observations per subject.
```{r}
n_obs |>  
  ggplot(aes(x = median_nobs)) +
  geom_histogram(bins = 50, color = "black", fill = "white") +
  xlab("# of GPS observations")
```

```{r}
n_obs |>  
  ggplot(aes(x = mean_nobs)) +
  geom_histogram(bins = 50, color = "black", fill = "white") +
  xlab("# of GPS observations")
```

```{r}
n_obs |>  
  ggplot(aes(x = per_missing)) +
  geom_histogram(bins = 50, color = "black", fill = "white") +
  xlab("# of GPS observations")
```

Create std_obs, a scaled version of n_obs based on total number of observations and days on study per subject.
```{r}
gps_obs <- gps_obs |>
  group_by(subid) |> 
  summarize(total_obs = sum(n_obs),
         total_days = n(),
         std_obs = total_obs/total_days)
```

Display histogram of # observations per subject on same scale.
```{r}
gps_obs |>  
  ggplot(aes(x = std_obs)) +
  geom_histogram(bins = 10, color = "black", fill = "white") +
  xlab("# of GPS observations (scaled)")

gps_obs |> mutate(std_obs = round(std_obs)) |> tab(std_obs)
# check out our subject with the highest scaled # of obs
gps_obs |> 
  filter(std_obs > 350) |>
  select(subid, total_obs, total_days, std_obs) |> 
  unique()
```

### Number of observations per day

**Calculated with missing days included.**

Subset data frame to display average observations per day, SD, minimum observation, and maximum observation per subject.
```{r}
obs_per_day <- gps_obs |>
  group_by(subid) |>  
  summarise(avg_obs_per_day = mean(n_obs),
            sd = sd(n_obs),
            min = min(n_obs),
            max = max(n_obs)) 
```

Display minimum average observation per day and maximum average observation per day across subjects.
```{r}
min(obs_per_day$avg_obs_per_day)
max(obs_per_day$avg_obs_per_day)
```

Display minimum observations per day and maximum observations per day across subjects.
```{r}
min(obs_per_day$min)
max(obs_per_day$max)
```

Display average observations per day across all subjects (average of average observations per day).
```{r}
mean(obs_per_day$avg_obs_per_day)
```

Histogram of standard deviations (to look at high and low variance subjects).

> Consider filtering out data points that are a certain # of SDs above a participant's average number of points? Alternatively, could we think of using this as a feature?

```{r}
obs_per_day |>  
  ggplot(aes(x = sd)) +
  geom_histogram(bins = 10, color = "black", fill = "white") +
  xlab("Standard deviation of number of observations per day, by subject")

# check out our subject with the highest standard deviation
obs_per_day |> 
  filter(sd > 300) |>
  select(subid, avg_obs_per_day, sd) |> 
  unique()
```

### Display number of observations by day per subject
```{r}
gps_obs |> 
  group_by(subid) |>
  print_kbl() |> 
  scroll_box(width = "700px", height = "200px")
```

### Plot number of observations by day per subject

Create timeseries plotting function.
```{r}
plot_timeseries <- function(x, y, z) {
    #gps_obs <- gps_obs |> filter(subid == z)
    gps_obs <- gps_obs |> filter(subid == z)
    
    graph_title <- paste0("Subject ID", z, sep = " ")
  
    #ggplot(data = gps_obs, aes(x = .data[[x]], y = .data[[y]], color = z)
    print(ggplot(data = gps_obs, aes(x = .data[[x]], y = .data[[y]], color = z)) +
          geom_line(color = "darkblue")) +
      labs(title = graph_title) +
      geom_hline(aes(yintercept = mean(n_obs), color = "red"), linetype = 2, show.legend = FALSE)
}
```

Get list of subjects.
```{r}
subid_all <- list(gps_obs$subid) |> unlist() |> unique()
```

If pdf output file does not already exist, create and save out plots in /data_processed/gps/subject-maps.
```{r}
if(file.exists(here::here(path_maps, "per-subj-timeseries.pdf"))){

  message("PDF file already exist -- delete to recreate!")

} else{
  timeseries_plots <- subid_all |>
    map(\(subid) plot_timeseries("date_central", "n_obs", subid))
    #map(\(subid) plot_timeseries("date_central", "n_obs", subid))
  
  output_file <- paste0(path_maps, "/per-subj-timeseries.pdf", sep = "")

  multi.page <- ggpubr::ggarrange(plotlist = timeseries_plots,
                                  nrow = 3, ncol = 1)
  ggpubr::ggexport(multi.page, filename = output_file)
}
```

### Examine 1-observation days

Filter on days that have only one observation, sorting ascending on time to ensure that the individual points on these days are not all occurring around midnight (which would suggest spurious bursts of activity not actually related to the participant).
```{r}
full_join(gps, gps_obs, by=c("subid", "date_central")) |> 
  select(subid, lat, lon, time, n_obs) |> 
  filter(n_obs == 1) |>
  separate_wider_delim(time, delim = " ", names = c("date", "time")) |> 
  arrange(time) |> 
  kable(caption = "1-observation days") |>
  kable_styling("striped") |> 
  scroll_box(width = "700px", height = "400px")
```

### Compare start and end dates

Extract first and last dates in GPS data per subject.
```{r}
gps_dates <- gps |>
  group_by(subid) |> 
  arrange(date_central) |> 
  slice(1, n()) |>
  mutate(start_study_gps = first(date_central),
         end_study_gps = last(date_central)) |> 
  select(subid, start_study_gps, end_study_gps) |> 
  distinct()
```

Extract start and end study dates from visit_dates.
```{r}
study_dates <- study_dates |>
  select(subid, study_start, study_end) |> 
  mutate(start_study_record = date(study_start),
         end_study_record = date(study_end)) |> 
  select(-study_start, -study_end)
```

Combine data frames.
```{r}
merge_dates <- left_join(gps_dates, study_dates)

merge_dates <- merge_dates[, c("subid", "start_study_record", "start_study_gps", "end_study_record", "end_study_gps")]
```

Display comparison table of start and end dates.
```{r}
merge_dates |>
  kable(caption = "Comparison of start and end study dates based on staff records and GPS data collection") |>
  kable_styling("striped") |> 
  scroll_box(width = "700px", height = "400px")
```

Calculate differences between date start and GPS start.
```{r}
merge_dates |>
  mutate(diff = start_study_record - start_study_gps) |>
  select(-end_study_record, -end_study_gps) |> 
  arrange(desc(diff)) |> 
  kable(caption = "Differences between study start and GPS start") |>
  kable_styling("striped") |> 
  scroll_box(width = "700px", height = "400px")
```

Calculate differences between date end and GPS end.

> GPS collection ending after the end of study doesn't matter because we won't be using that data in any case.

```{r}
merge_dates |>
  mutate(diff = end_study_record - end_study_gps) |>
  select(-start_study_record, -start_study_gps) |> 
  arrange(diff) |> 
  kable(caption = "Differences between study end and GPS end") |>
  kable_styling("striped") |> 
  scroll_box(width = "700px", height = "400px")
```

Calculate number of days on study.

> Already calculated above to standardize our # of GPS observations, but maybe useful to look at in a table?

```{r}
merge_dates |>
  mutate(diff = end_study_record - start_study_record) |>
  select(-start_study_gps, -end_study_gps) |> 
  arrange(diff) |> 
  kable(caption = "Number of days on study") |>
  kable_styling("striped") |> 
  scroll_box(width = "700px", height = "400px")
```

## GPS maps

Other map options we might be interested in generating for QC are interactive ones where you can move around (see Figure 1: https://journals.sagepub.com/doi/full/10.1177/25152459221082680).

### Static

Create function to generate static map per subject.
```{r}
plot_geo <- function(z) {
    gps <- gps |> filter(subid == z)
    
    graph_title <- paste0("Subject ID", z, sep = " ")
   
    cbbox <- make_bbox(lon = gps$lon, lat = gps$lat, f = .1)
    sq_map <- get_map(location = cbbox, maptype = "stamen_toner_lite")
    
    ggmap(sq_map) + 
      geom_path(data = gps, aes(x = gps$lon, y = gps$lat), 
                size = 1, lineend = "round", color="darkred") +
      labs(x = " ", y = " ", title = graph_title) +
      theme_minimal() +
      theme(legend.position = "none")
}
```

Generate subject ID list.
```{r}
subid_all <- list(gps$subid) |> unlist() |> unique()
```

Generate individual GPS map per subject and save out in /shared/gps/subject-maps if compiled file does already not exist.
```{r}
#| eval: false
#| label: Static subject maps

if(file.exists(here::here(path_gps, "per-subj-geo.pdf"))){

  message("PDF file already exist -- delete to recreate!")

} else{
  geo_plots <- subid_all |> 
    map(\(subid) plot_geo(subid))
  
  output_file <- paste0(path_gps, "/per-subj-geo.pdf", sep = "")

  multi.page <- ggpubr::ggarrange(plotlist = geo_plots,
                                    nrow = 1, ncol = 1)

  ggpubr::ggexport(multi.page, filename = output_file)
}
```

### Dynamic

Create gifs displaying participant movement during study duration. Note: this takes a *long* time to run -- recommend subsetting data for a particular subject as opposed to generating map for entire duration on study.

```{r}
#| eval: false
#| label: Dynamic subject maps

gps_mini <- gps |> filter(subid == "1" & time < "2017-03-02 16:07:24")

gps_mini <- gps_mini[!duplicated(gps_mini$time),]

gps_mini_moves <- df2move(gps_mini,
        proj = "+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0", 
        x = "lon", y = "lat", time = "time", track_id = "subid")

# align move_data to a uniform time scale
m <- align_move(gps_mini_moves, res = 4, unit = "mins")


frames <- frames_spatial(m, path_colours = c("darkred"),
                         map_service = "osm", map_type = "streets",
                         alpha = 0.5) |>  
  add_labels(x = "Longitude", y = "Latitude") |>
  add_northarrow() |>  
  add_scalebar() |> 
  add_timestamps(type = "label") |>  
  add_progress()

frames[[10]] # preview frame

# animate frames
animate_frames(frames, out_file = "moveVis.gif")
```